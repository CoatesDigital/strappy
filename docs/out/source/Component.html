<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='framework-Component'>/**
</span> * @class framework.Component
 * The core class which all components extend from.
 * 
 * Components are the heart of the framework. Each component is in itself a core,
 * which means that each component is stand-alone and not dependant on any other
 * component to operate.
 * 
 * This is the core goal of the framework. If a component is not able to conform
 * to this pattern, then something is wrong with how the component has been built.
 * 
 * This class is designed to be extended from. You should never need to add any
 * additional logic in the extended class. That logic should be placed within
 * controllers and associated with this component.
 * 
 * When you extend this class, you should only need to define configuration for
 * child components, models, views and controllers.
 * 
 * More often than not, your component will require custom signals. These signals
 * should be pre-defined for consistancy and maintainability within your 
 * 
 * An example of a component, with custom signals.
 * 
	$JSKK.Class.create
	(
		{
			$namespace:	'Application.component',
			$name:		'MyComponent',
			$extends:	framework.Component
		}
	)
	(
		{
			SIGNAL:
			{
				LOGIN_SUCCESS:		'myComponent.login.success',
				LOGIN_FAILURE:		'myComponent.login.fail'
			}
		},
		{
			components:
			{
				loginForm:		'Application.component.LoginForm',
				errorWindow:	'Application.component.DialogWindow',
				successWindow:	'Application.component.DialogWindow'
			},
			stores:
			[
				'State',
				'User'
			],
			views:
			[
				'Default'
			],
			controllers:
			[
				'State',
				'Default'
			]
		}
	);
 * 
 * @mixins $JSKK.trait.Observable
 * @abstract
 * 
 * @uses $JSKK.trait.Observable
 * @uses framework.RadioTower
 * @uses framework.StateMgr
 */
$JSKK.Class.create
(
	{
		$namespace:	'framework',
		$name:		'Component',
		$uses:
		[
			$JSKK.trait.Observable
		]
	}
)
(
	{},
	{
		events:
		{
			onConfigured:	true
		},
<span id='framework-Component-cfg-attachTo'>		/**
</span>		 * @cfg attachTo The DOM element that this component will attach itself to. (required)
		 */
		config:
		{
			attachTo:	null
		},
<span id='framework-Component-property-browser'>		/**
</span>		 * @property browser Contains browser information.
		 * @property browser.name The name of the browser.
		 * @property browser.version The version of the browser.
		 * @readonly
		 */
        browser:
		{
			name:		null,
			version:	null
		},
<span id='framework-Component-property-components'>		/**
</span>		 * @property components Specifiy a list of child components.
		 * 
	$JSKK.Class.create
	(
		{
			$namespace:	'Application.component',
			$name:		'MyComponent',
			$extends:	framework.Component
		}
	)
	(
		{},
		{
			components:
			{
				loginForm:		'Application.component.LoginForm',
				errorWindow:	'Application.component.DialogWindow',
				successWindow:	'Application.component.DialogWindow'
			}
		}
	);
		 * 
		 */
		components:		{},
<span id='framework-Component-property-stores'>		/**
</span>		 * @property stores Specify a list of stores to pre-load.
		 * 
	$JSKK.Class.create
	(
		{
			$namespace:	'Application.component',
			$name:		'MyComponent',
			$extends:	framework.Component
		}
	)
	(
		{},
		{
			stores:
			[
				'State',
				'User'
			]
		}
	);
		 */
		stores:			[],
<span id='framework-Component-property-views'>		/**
</span>		 * @property views Specify a list of views to pre-load.
		 * 
	$JSKK.Class.create
	(
		{
			$namespace:	'Application.component',
			$name:		'MyComponent',
			$extends:	framework.Component
		}
	)
	(
		{},
		{
			views:
			[
				'Default'
			]
		}
	);
		 */
		views:			[],
<span id='framework-Component-property-controllers'>		/**
</span>		 * @property controllers Specify a list of controllers to pre-load.
		 * 
	$JSKK.Class.create
	(
		{
			$namespace:	'Application.component',
			$name:		'MyComponent',
			$extends:	framework.Component
		}
	)
	(
		{},
		{
			controllers:
			[
				'State',
				'Default'
			]
		}
	);
		 */
		controllers:	[],
<span id='framework-Component-property-_stores'>		/**
</span>		 * @property _stores A container for all the initialized stores.
		 * @private
		 */
		_stores:		{},
<span id='framework-Component-property-_views'>		/**
</span>		 * @property _views A container for all the initialized views.
		 * @private
		 */
		_views:			{},
<span id='framework-Component-property-_controllers'>		/**
</span>		 * @property _controllers A container for all the initialized controllers.
		 * @private
		 */
		_controllers:	{},
<span id='framework-Component-property-_configured'>		/**
</span>		 * @property _configured A flag to indicate weather or not this component has been configured.
		 * @private
		 */
		_configured:	false,
<span id='framework-Component-property-my'>		/**
</span>		 * @property my A special object containing information relevant to this class.
		 * @property my.name The name of this class.
		 * @property my.index The position this component lives in within the stack of 
		 * components registered against the framework.
		 * @property my.NSObject The namespace in an object format of this class.
		 * @readonly
		 */
		my:
		{
			name:		null,
			index:		null,
			NSObject:	null
		},
<span id='framework-Component-property-radioTower'>		/**
</span>		 * @property radioTower A reference to the {@link framework.RadioTower Radio Tower}. 
		 * @private
		 */
		radioTower: null,
<span id='framework-Component-property-stateMgr'>		/**
</span>		 * @property stateMgr A reference to the {@link framework.StateMgr State Manager}. 
		 * @private
		 */
		stateMgr:	null,
<span id='framework-Component-method-constructor'>		/**
</span>		 * @constructor
		 * Sets up the component by initalizing all it's child components,
		 * views, models and controllers.
		 * 
		 * Additionally, it connects the component to the Radio Tower,
		 * enabling signals, and the State Manager, enabling state to be
		 * captured/restored.
		 * 
		 * Note: The constructor automatically calls {@link framework.Component#reconfigure reconfigure}
		 * when it is done.
		 * 
		 * @return {framework.Component}
		 */
        init: function()
		{
			this.my.name		=this.$reflect('name');
			this.my.namespace	=this.$reflect('namespace').split('.');
			
			if (Object.isUndefined(window.framework.$components))
            {
				window.framework.$components={};
			}
            if (Object.isUndefined(window.framework.$components[this.my.name]))
            {
            	window.framework.$components[this.my.name]=[];
            }
			
			this.my.index		=window.framework.$components[this.my.name].push(this);
			this.my.NSObject	=window;
			
			for (var i=0,j=this.my.namespace.length; i&lt;j; i++)
			{
				this.my.NSObject=this.my.NSObject[this.my.namespace[i]];
			}
			this.initRadioTower();
			this.initStateMgr();
			this.initChildComponents();
			this.initViews();
			this.initStores();
			this.initControllers();
			
			if (Object.isFunction(this.initCmp))
			{
				this.initCmp();
			}
			this.ready=true;
		},
<span id='framework-Component-method-initRadioTower'>		/**
</span>		 * Initalizes the component's conneciton to the Radio Tower.
		 * 
		 * The Radio Tower enables signals to flow through this component.
		 * 
		 * @return {void}
		 */
		initRadioTower: function()
		{
			if (Object.isUndefined(window.framework.$radioTower))
			{
				window.framework.$radioTower=new framework.RadioTower();
			}
			this.radioTower=window.framework.$radioTower;
		},
<span id='framework-Component-method-initStateMgr'>		/**
</span>		 * Initalizes the component's connection to the State Manager.
		 * 
		 * The State Manager
		 */
		initStateMgr: function()
		{
			if (Object.isUndefined(window.framework.$stateMgr))
			{
				window.framework.$stateMgr=new framework.StateMgr();
			}
			this.stateMgr=window.framework.$stateMgr;
		},
<span id='framework-Component-method-getBrowser'>		/**
</span>		 * Gets the browser info. Note that this is currently tied to jQuery.
		 * @private
		 */
		getBrowser: function()
		{
			if (Object.isNull(this.browser.name))
			{
				// setup browser object.
				if (Object.isDefined(jQuery.browser.msie))
				{
					this.browser.name='ie';
				}
				else if (Object.isDefined(jQuery.browser.webkit))
				{
					this.browser.name='webkit';
				}
				else if (Object.isDefined(jQuery.browser.opera))
				{
					this.browser.name='opera';
				}
				else if (Object.isDefined(jQuery.browser.mozilla))
				{
					this.browser.name='mozilla';
				}
				this.browser.version=jQuery.browser.version.split('.')[0];
			}
		},
<span id='framework-Component-method-initChildComponents'>		/**
</span>		 * Initializes all the child components associated with this component.
		 * 
		 * @private
		 */
		initChildComponents: function()
		{
			var parts		=null,
				config		=null,
				object		=null;
			for (var component in this.components)
			{
				parts		=this.components[component].split('.');
				object		=window[parts[0]];
				if (Object.isDefined(object))
				{
					for (var i=1,j=parts.length; i&lt;j; i++)
					{
						if (Object.isDefined(object[parts[i]]))
						{
							object=object[parts[i]];
						}
						else
						{
							throw new Error('Error! component &quot;'+this.components[component]+'&quot; not loaded.');
							break;
						}
					}
				}
				else
				{
					throw new Error('Error! component &quot;'+this.components[component]+'&quot; not loaded.');
					break;
				}
				this.components[component]=new object();
			}
		},
<span id='framework-Component-method-newChildComponent'>		/**
</span>		 * Creates a new child component.
		 * 
		 * This can be useful for when you want to dynamically
		 * create child components.
		 * 
	$JSKK.Class.create
	(
		{
			$namespace:	'Application.component.myComponent.controller',
			$name:		'Default',
			$extends:	framework.mvc.Controller
		}
	)
	(
		{},
		{
			onGotBaseHTML: function(view)
			{
				var thisChildCmp=null;
				for (var i=0; i&lt;10; i++)
				{
					thisChildCmp=this.getParentComponent().newChildComponent('Application.component.Tile');
					thisChildCmp.configure({attachTo:view.getContainer()});
				}
			}
		}
	);
		 * 
		 */
		newChildComponent: function(component)
		{
			var parts		=component.split('.'),
				object		=window[parts[0]],
				config		=null;
			
			if (Object.isDefined(object))
			{
				for (var i=1,j=parts.length; i&lt;j; i++)
				{
					if (Object.isDefined(object[parts[i]]))
					{
						object=object[parts[i]];
					}
					else
					{
						throw new Error('Error! component &quot;'+this.components[component]+'&quot; not loaded.');
						break;
					}
				}
			}
			else
			{
				throw new Error('Error! component &quot;'+this.components[component]+'&quot; not loaded.');
			}
			if (!Object.isDefined(this.components[component]))
			{
				this.components[component]=[];
			}
			var cmp=new object();
			this.components[component].push(cmp);
			return cmp;
		},
<span id='framework-Component-method-getCmp'>		/**
</span>		 * Returns a child component which is pre-defined in this
		 * components &quot;components&quot; property.
		 * 
		 * @param {String} cmpName The reference name of the component to get as
		 * defined by this component.
		 * @throws Error If the component is not registered.
		 * @return {framework.Component} the requested component.
		 */
		getCmp: function(cmpName)
		{
			if (Object.isDefined(this.components[cmpName]))
			{
				return this.components[cmpName];
			}
			else
			{
				throw new Error('Unable to get component &quot;'+cmpName+'&quot;. This component has not been registered.');
			}
		},
<span id='framework-Component-method-initControllers'>		/**
</span>		 * Initializes all the controllers associated with this component.
		 * 
		 * @private
		 */
		initControllers: function()
		{
			for (var i=0,j=this.controllers.length; i&lt;j; i++)
			{
				if (Object.isDefined(this.my.NSObject[this.my.name.lowerFirst()].controller[this.controllers[i]]))
				{
					this._controllers[this.controllers[i]]=new this.my.NSObject[this.my.name.lowerFirst()].controller[this.controllers[i]](this);
				}
				else
				{
					throw new Error('Error controller &quot;'+this.controllers[i]+'&quot; not loaded.');
					break;
				}
			}
		},
<span id='framework-Component-method-getController'>		/**
</span>		 * Returns an associated controller which is pre-defined in this
		 * components &quot;controllers&quot; property.
		 * 
		 * @param {String} controller The name of the controller to get.
		 * @throws Error if the controller has not been initilized.
		 * @return {framework.mvc.View} The requested controller if it has been defined.
		 */
		getController: function(controller)
		{
			if (Object.isDefined(this._controllers[controller]))
			{
				return this._controllers[controller];
			}
			else
			{
				throw new Error('Error - controller &quot;'+controller+'&quot; has not been initilized.');
			}
		},
<span id='framework-Component-method-initViews'>		/**
</span>		 * Initializes all the views associated with this component.
		 * 
		 * @private
		 */
		initViews: function()
		{
			for (var i=0,j=this.views.length; i&lt;j; i++)
			{
				if (Object.isDefined(this.my.NSObject[this.my.name.lowerFirst()])
				&amp;&amp; Object.isDefined(this.my.NSObject[this.my.name.lowerFirst()].view[this.views[i]]))
				{
					this._views[this.views[i]]=new this.my.NSObject[this.my.name.lowerFirst()].view[this.views[i]](this);
				}
				else
				{
					throw new Error('Error - view &quot;'+this.views[i]+'&quot; not loaded.');
					break;
				}
			}
		},
<span id='framework-Component-method-getView'>		/**
</span>		 * Returns an associated view which is pre-defined in this
		 * components &quot;views&quot; property.
		 * 
		 * @param {String} view The name of the view to get.
		 * @throws Error if the view has not been initilized.
		 * @return {framework.mvc.View} The requested view if it has been defined.
		 */
		getView: function(view)
		{
			if (Object.isDefined(this._views[view]))
			{
				return this._views[view];
			}
			else
			{
				throw new Error('Error - view &quot;'+view+'&quot; has not been initilized.');
			}
		},
<span id='framework-Component-method-initStores'>		/**
</span>		 * Initializes all the stores associated with this component.
		 * 
		 * @private
		 */
		initStores: function()
		{
			for (var i=0,j=this.stores.length; i&lt;j; i++)
			{
				if (Object.isDefined(this.my.NSObject[this.my.name.lowerFirst()])
				&amp;&amp; Object.isDefined(this.my.NSObject[this.my.name.lowerFirst()].store[this.stores[i]]))
				{
					this._stores[this.stores[i]]=new this.my.NSObject[this.my.name.lowerFirst()].store[this.stores[i]](this);
				}
				else
				{
					throw new Error('Error - store &quot;'+this.stores[i]+'&quot; not loaded for component &quot;'+this.my.name+'&quot;.');
					break;
				}
			}
		},
<span id='framework-Component-method-getStore'>		/**
</span>		 * Returns an associated store which is pre-defined in this
		 * components &quot;models&quot; property.
		 * 
		 * @param {String} store The name of the store to get.
		 * @throws 
		 * @return {framework.mvc.Model} The requested store if it has been defined.
		 */
		getStore: function(store)
		{
			if (Object.isDefined(this._stores[store]))
			{
				return this._stores[store];
			}
			else
			{
				throw new Error('Error - store &quot;'+store+'&quot; has not been initilized.');
			}
		},
<span id='framework-Component-method-configure'>		/**
</span>		 * Configures this component with new configuration properties.
		 * 
		 * @param {Object} newConfig The new configuration object.
		 * @return {void}
		 */
		configure: function(newConfig)
		{
			$JSKK.when(this,'ready').isTrue
			(
				function()
				{
					if (Object.isDefined(this.config))
					{
						Object.extend(this.config,newConfig);
					}
					else
					{
						this.config=newConfig;
					}
					this._configured=true;
					this.fireEvent('onConfigured',this);
					this.sendSignal(framework.Signal.CMP_DO_RECONFIGURE,{component:this.my.name});
				}.bind(this)
			);
		},
<span id='framework-Component-method-reconfigure'>		/**
</span>		 * Call this method to force the component to reconfigure itself.
		 * 
		 * This essentially calls the {@link }
		 * 
		 * @return {void}
		 */
		reconfigure: function()
		{
			$JSKK.when(this,'ready').isTrue
			(
				function()
				{
					this.configure(this.config);
//					this.sendSignal(framework.Signal.CMP_DO_RECONFIGURE,{component:this.my.name});
				}.bind(this)
			);
		},
<span id='framework-Component-method-isConfigured'>		/**
</span>		 * A helper method to determine if this component has been configured.
		 * 
		 * @return {Boolean} true if this component has been configured.
		 */
		isConfigured: function()
		{
			return this._configured;
		},
<span id='framework-Component-method-getConfig'>		/**
</span>		 * Fetches a config item associated with this component.
		 * 
		 * @return {Mixed} The config item's value. 
		 */
		getConfig:		function(key)
		{
			var	parts	=key.split('.'),
				object	=this.config;
			for (var i=0,j=parts.length; i&lt;j; i++)
			{
				if (Object.isDefined(object[parts[i]]))
				{
					object=object[parts[i]];
				}
				else
				{
					return null;
				}
			}
			return object;
		},
<span id='framework-Component-method-getID'>		/**
</span>		 * Calculates the ID of this component based off of
		 * its namespace and name.
		 * 
		 * @return {String} The ID of this component or the M/V/C class
		 * associated with this component.
		 */
		getID: function()
		{
			var id=[];
			Object.extend(id,this.namespace);
			id.push(this.className);
			return id.join('.');
		},
<span id='framework-Component-method-sendSignal'>		/**
</span>		 * See {@link framework.trait.signal.Send#sendSignal}
		 * @private
		 */
		sendSignal: function(name,body,type,filter)
		{
			console.debug(this.$reflect('namespace')+'.'+this.$reflect('name'),':: sendSignal(core) :: ',name);
			if (!Object.isEmpty(name))
			{
				$JSKK.when(this,'radioTower').isAssocArray
				(
					function()
					{
						this.radioTower.fireEvent
						(
							name,
							new framework.Signal
							(
								{
									name:	name,
									body:	body,
									type:	type,
									filter:	filter
								}
							)
						);
					}.bind(this)
				);
			}
			else
			{
				throw new Error('Class '+this.className+' attempted to fire an empty signal.');
			}
		}
	}
);</pre>
</body>
</html>
